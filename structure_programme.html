<!DOCTYPE HTML>
<!--
  Industrious by TEMPLATED
  templated.co @templatedco
  Released for free under the Creative Commons Attribution 3.0 license (templated.co/license)
-->
<html>
  <head>
  <title>Structure du programme</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <meta name="description" content="" />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="assets/css/main.css" />
  </head>
  <body class="is-preload">

    <!-- Header -->
      <header id="header">
        <a class="logo" href="index.html">Projet 3BIM</a>
        <nav>
          <a href="#menu">Menu</a>
        </nav>
      </header>

    <!-- Nav -->
      <nav id="menu">
        <ul class="links">
          <li><a href="index.html">Page d'accueil</a></li>
          <li><a href="structure_programme.html">Structure du programme</a></li>
          <li><a href="observations.html">Expérimentations & Résultats</a></li>
          <li><a href="parallele_biologique.html">Parallèle biologique</a></li>
          <li><a href="problemes.html">Problèmes rencontrés</a></li>
          <li><a href="plus_loin.html">Pour aller plus loin</a></li>
          <li><a href="bibliographie.html">Bibliographie</a></li>
        </ul>
      </nav>

    <!-- Heading -->
      <div id="heading" >
        <h1>Structure du programme</h1>
      </div>

    <!-- Main -->
      <section id="main" class="wrapper">
        <div class="inner">
          <div class="content">
            <header>
              <h2>Graphe orienté</h2>
            </header>
            <p>Nos individus, pour être capables de jouer, ont besoin d’une intelligence, au sens large du terme. En effet, ils doivent être en mesure de réagir aux différentes situations dans lesquelles ils se trouvent. C’est cette aptitude à agir selon le contexte que nous appelons intelligence, et c’est cette intelligence que nous cherchons à développer et complexifier.
            </p>
             <p>Nos individus ont une liste préétablie d’actions possibles. Ils ont également une vision de leur environnement immédiat (input). Nous voulons que leur réaction à cet environnement immédiat (output) soit la plus adaptée possible. La qualité de cette réaction correspond à la pertinence de l’action choisie par l’individu par rapport à la situation. 
             </p>

            <div class="image"><img src="images/girafe.png"/></div>

            <hr />
            <h3>Adaptation de l'algorithme au problème</h3>
            <p>Ces algorithmes sont souvent utilisés pour résoudre des problèmes d’optimisation. Dans notre cas, l’objectif est de générer des “individus-solutions”  adaptés à leur milieu, c’est à dire aptes à y survivre. En d’autres termes, nous cherchons à construire des individus capables de surmonter les difficultés d’un jeu.</p>
            <p>Nos individus vont ainsi évoluer dans des “niveaux”, qui peuvent être de difficulté différente. Ce sont ces niveaux qui nous permettent d'entraîner nos individus, c’est à dire d'en faire des intelligences artificielles.</p>
            <p>Comme dans tous les algorithmes évolutifs, nos individus  sont caractérisés par leur génotype (leur matrice décisionnelle). L’expression de ce génotype, c’est à dire leur phénotype, correspond à leur comportement face au jeu. La qualité de ce comportement est évaluée, c’est ce que l’on appelle la fitness. Plus la fitness est élevée, plus l’individu est susceptible d’être sélectionné.</p>
            <hr />
            <h3> L'algorithme concrètement</h3>
            <p>Notre algorithme comporte plusieurs étapes:
            <ul style= "list-style-type: square">
              <li><B> Génération </B> d’une population initiale d’individus naïfs. Cette génération est aléatoire. En effet, avoir une grande diversité initiale permet d’augmenter la probabilité de trouver à terme un individu performant.</li>
              <li><B>Evaluation</B> de ces individus (confrontation au jeu). Il s’agit ici de faire jouer nos individus, c’est à dire de leur faire parcourir le niveau en un temps limité.</li>
              <li><B>Sélection</B> du/des meilleur(s) individu(s). Nous avons fait le choix de prendre pour fitness la distance parcourue par l’individu depuis son départ. Celui (ceux) ayant été le plus loin dans le niveau est(sont) donc sélectionné(s)</li>     
              <li><B>Reproduction</B> du/des individu(s) sélectionné(s)</li>    
              <li><B>Mutation</B> des descendants générés à l'étape précédente</li>        
</ul>
Ces deux dernières étapes permettent de créer  une nouvelle génération <I>n+1</I>. Les individus de cette génération partagent une partie des caractéristiques de leur(s) ascendant(s), mais présentent également des mutations dans leur génome. Ces variations permettent d’explorer localement l’espace des solutions, dans l’objectif de converger à terme vers un minimum.</p>
 <p>On répète cette boucle jusqu’à atteindre un critère d’arrêt, qui peut varier selon les algorithmes. Dans notre cas, la boucle s’arrête soit quand un individu a réussi à résoudre le problème posé, donc à terminer le niveau testé, soit quand le temps maximum autorisé est atteint. Ce critère d'arrêt secondaire est nécessaire pour éviter une boucle infinie en cas de niveau non solvable.</p>

            
            <header>
            	<h2>Choix d'implémentation </h2>
            </header>
            
            <p>Les principales exigences de ce projet en matière de programmation étaient au nombre de trois. Premièrement, pouvoir créer, en l’état actuel de nos connaissances, une structure POO (environnement, individu, génome) assez riche pour permettre la construction de l’algorithme évolutif. Deuxièmement, avoir un code performant, qui puisse réaliser dans un temps court les nombreux calculs nécessaires à la génération, l’évaluation et la sélection des individus. Enfin, pouvoir programmer une interface graphique, pour visualiser l’évolution de nos individus et s’assurer qu’ils jouent correctement.</p>
<p>Nous avons donc choisi de coder en python. Bien que ce langage soit beaucoup moins optimisé que d’autres, ses bibliothèques en font un compromis intéressant. Ainsi <I>numpy</I> permet de réaliser les calculs rapidement, tandis que <I>tkinter</I> est un module offrant la possibilité de générer des fenêtres graphiques. De plus, nous voulions éviter de nous engager dans des impasses. Python est là aussi idéal car il permet d'implémenter des prototypes rapidement. Cela nous a donné la possibilité de mettre nos idées à l'épreuves. </p>
</p>
          </div>
        </div>
      </section>

    <!-- Scripts -->
      <script src="assets/js/jquery.min.js"></script>
      <script src="assets/js/browser.min.js"></script>
      <script src="assets/js/breakpoints.min.js"></script>
      <script src="assets/js/util.js"></script>
      <script src="assets/js/main.js"></script>

  </body>
</html>
